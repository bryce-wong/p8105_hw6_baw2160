---
title: "p8105_hw6_baw2160"
author: "Bryce Wong"
date: "November 18, 2018"
output: github_document
---

```{r}
library(tidyverse)
library(modelr)
library(mgcv)

theme_set(theme_bw() + theme(legend.position = "bottom"))
set.seed(1)
```

### Problem 1:

Loading the data: 

```{r, message = FALSE}
 hom_data = read_csv("https://raw.githubusercontent.com/washingtonpost/data-homicides/master/homicide-data.csv")
```

* Create a city_state variable (e.g. “Baltimore, MD”), and a binary variable indicating whether the homicide is solved. 
* Omit cities Dallas, TX; Phoenix, AZ; and Kansas City, MO – these don’t report victim race. Also omit Tulsa, AL – this is a data entry mistake. 
* Modifiy victim_race to have categories white and non-white, with white as the reference category. 
* Be sure that victim_age is numeric.

```{r}
hom_data_tidied = hom_data %>% 
  mutate(city_state = str_c(city, ", ", state)) %>% 
  filter(!(city_state %in% c("Dallas, TX", "Phoenix, AZ", "Kansas City, MO", "Tulsa, AL"))) %>% 
  mutate(resolved = as.numeric(disposition == "Closed by arrest"),
         victim_age = as.numeric(victim_age),
         victim_race = ifelse(victim_race == "White", "white", "non-white"),
         victim_race = fct_relevel(victim_race, "white")) %>% 
  select(city_state, resolved, victim_age, victim_race, disposition, everything())
```

* For the city of Baltimore, MD, use the glm function to fit a logistic regression with resolved vs unresolved as the outcome and victim age, sex and race (as just defined) as predictors. 
* Save the output of glm as an R object; apply the broom::tidy to this object; and obtain the estimate and confidence interval of the adjusted odds ratio for solving homicides comparing black victims to white victims keeping all other variables fixed.

```{r}
baltimore_glm = 
  hom_data_tidied %>% 
  filter(city_state == "Baltimore, MD") %>% 
  glm(resolved ~ victim_age + victim_race + victim_sex, data = ., family = binomial()) %>% 
  broom::tidy(conf.int = TRUE) %>% 
  mutate(
    OR = exp(estimate),
    OR_conf.low = exp(conf.low),
    OR_conf.high = exp(conf.high)
    ) %>%
  filter(term == "victim_racenon-white") %>% 
  select(term, log_OR = estimate, OR, OR_conf.low, OR_conf.high, p.value) %>% 
  knitr::kable(digits = 3)

baltimore_glm
```

* Now run glm for each of the cities in your dataset, and extract the adjusted odds ratio (and CI) for solving homicides comparing black victims to white victims. 
    * Do this within a “tidy” pipeline, making use of purrr::map, list columns, and unnest as necessary to create a dataframe with estimated ORs and CIs for each city.

```{r}
glm_function = function(data, name){
  city_state_glm = data %>% 
  filter(city_state == name) %>% 
  unnest() %>% 
  glm(resolved ~ victim_race + victim_age + victim_sex, data = ., family = binomial()) %>% 
  broom::tidy(conf.int = TRUE) %>% 
  mutate(
    OR = exp(estimate),
    OR_conf.low = exp(conf.low),
    OR_conf.high = exp(conf.high)
    ) %>%
  filter(term == "victim_racenon-white") %>% 
  select(term, log_OR = estimate, OR, OR_conf.low, OR_conf.high, p.value)
  
  city_state_glm
}
```

```{r}
all_cities_glm = hom_data_tidied %>% 
  nest(resolved:lon) %>% 
  mutate(
    models = map(.x = city_state, ~glm_function(data = hom_data_tidied, name = .x))
    ) %>% 
  select(city_state, models) %>% 
  unnest()

#glm_function(data = hom_data_race, name = "Baltimore, MD")
```

* Create a plot that shows the estimated ORs and CIs for each city. 
* Organize cities according to estimated OR, and comment on the plot.

```{r}
all_cities_glm %>%
  mutate(city_state = fct_reorder(city_state, OR)) %>% 
  ggplot(aes(x = city_state, y = OR)) + 
  geom_point() +
  geom_errorbar(aes(x = city_state, ymin = OR_conf.high, ymax = OR_conf.low)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 6)) +
  labs(
    title = "Odds ratio for solving homicides comparing black to white victims",
    x = "City",
    y = "Odds Ratio"
  )
```

###Problem 2:

Load data:

```{r}
birthweight_data = read_csv("./data/birthweight.csv")
```

Clean data:

```{r}
birthweight_data = birthweight_data %>% 
  mutate(
    babysex = as.factor(babysex),
    frace = as.factor(frace),
    malform = as.factor(malform),
    mrace = as.factor(mrace)
  ) 
```

* Propose a regression model for birthweight. This model may be based on a hypothesized structure for the factors that underly birthweight, on a data-driven model-building process, or a combination of the two. 
* Describe your modeling process and show a plot of model residuals against fitted values – use add_predictions and add_residuals in making this plot.

Started with all predictors in the model:

```{r}
birthweight_full = lm(bwt ~ babysex + bhead + blength + delwt + fincome + frace + gaweeks + malform + menarche + mheight + momage + mrace + parity + pnumlbw + pnumsga + ppbmi + ppwt + smoken + wtgain, data = birthweight_data)

birthweight_full_tidy = birthweight_full %>% 
  broom::tidy() %>% 
  select(term, estimate, p.value) %>% 
  knitr::kable(digits = 3)

birthweight_full_tidy
```

Doesn't seem useful:
* fincome
* frace2-frace8 (missing frace5-7)
* malform1
* menarche
* mheight
* momage
* mrace3, mrace4
* parity
* ppbmi
* ppwt
* smoken

N/A - might mean these variables aren't linearly independent:
* pnumlbw
* pnumsga
* wtgain

```{r}
birthweight_2 = lm(bwt ~ babysex + bhead + blength + delwt + gaweeks + mrace, data = birthweight_data)

birthweight_2_tidy = birthweight_2 %>% 
  broom::tidy() %>% 
  select(term, estimate, p.value) %>% 
  knitr::kable(digits = 3)

birthweight_2_tidy
```

Adding back in variables I think make theoretical sense:
* smoken
* ppwt
* ppbmi

```{r}
birthweight_3 = lm(bwt ~ babysex + bhead + blength + delwt + gaweeks + mrace + smoken + ppbmi, data = birthweight_data)

birthweight_3_tidy = birthweight_3 %>% 
  broom::tidy() %>% 
  select(term, estimate, p.value) %>% 
  knitr::kable(digits = 3)

birthweight_3_tidy
```

ppbmi and ppwt seem to not be significant when the other is in the model. I'm considering ppbmi more important.

Comparing nested models - the full to the new one:

```{r}
anova(birthweight_3, birthweight_full) %>% 
  broom::tidy()
```

```{r}
birthweight_data %>% 
  modelr::add_residuals(birthweight_3) %>% 
  modelr::add_predictions(birthweight_3) %>% 
  ggplot(aes(x = bwt, y = resid)) +  
  geom_point() +
  geom_line(aes(y = pred), color = "red") +
  labs(
    title = "Predictions and Residuals",
    x = "Birthweight",
    y = "Predictions and Residuals"
  )
```

Compare your model to two others:

* One using length at birth and gestational age as predictors (main effects only)
* One using head circumference, length, sex, and all interactions (including the three-way interaction) between these

Make this comparison in terms of the cross-validated prediction error; use crossv_mc and functions in purrr as appropriate.

```{r}
cv_birthweight = crossv_mc(birthweight_data, 100)

cv_birthweight = 
  cv_birthweight %>% 
  mutate(
    proposed_mod = map(train, ~lm(bwt ~ babysex + bhead + blength + delwt + gaweeks + mrace + smoken + ppbmi, data = .x)),
    length_ga_mod = map(train, ~lm(bwt ~ blength + gaweeks, data = .x)),
    circ_length_sex_mod = map(train, ~lm(bwt ~ bhead * blength * babysex, data = .x))) %>% 
  mutate(
    rmse_proposed = map2_dbl(proposed_mod, test, ~rmse(model = .x, data = .y)),
    rmse_length_ga = map2_dbl(length_ga_mod, test, ~rmse(model = .x, data = .y)),
    rmse_circ_length_sex = map2_dbl(circ_length_sex_mod, test, ~rmse(model = .x, data = .y)))
```

```{r}
cv_birthweight %>% 
  select(starts_with("rmse")) %>% 
  gather(key = model, value = rmse) %>% 
  mutate(model = str_replace(model, "rmse_", ""),
         model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + geom_violin()
```


